{
	"patcher" : 	{
		"fileversion" : 1,
		"appversion" : 		{
			"major" : 8,
			"minor" : 6,
			"revision" : 1,
			"architecture" : "x64",
			"modernui" : 1
		}
,
		"classnamespace" : "dsp.gen",
		"rect" : [ 134.0, 134.0, 1373.0, 743.0 ],
		"bglocked" : 0,
		"openinpresentation" : 0,
		"default_fontsize" : 12.0,
		"default_fontface" : 0,
		"default_fontname" : "Arial",
		"gridonopen" : 1,
		"gridsize" : [ 15.0, 15.0 ],
		"gridsnaponopen" : 1,
		"objectsnaponopen" : 1,
		"statusbarvisible" : 2,
		"toolbarvisible" : 1,
		"lefttoolbarpinned" : 0,
		"toptoolbarpinned" : 0,
		"righttoolbarpinned" : 0,
		"bottomtoolbarpinned" : 0,
		"toolbars_unpinned_last_save" : 0,
		"tallnewobj" : 0,
		"boxanimatetime" : 200,
		"enablehscroll" : 1,
		"enablevscroll" : 1,
		"devicewidth" : 0.0,
		"description" : "",
		"digest" : "",
		"tags" : "",
		"style" : "",
		"subpatcher_template" : "",
		"assistshowspatchername" : 0,
		"boxes" : [ 			{
				"box" : 				{
					"id" : "obj-44",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 30.701754093170166, 486.842100620269775, 35.0, 22.0 ],
					"text" : "out 1"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-43",
					"maxclass" : "newobj",
					"numinlets" : 2,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 288.596488475799561, 54.385964393615723, 81.0, 22.0 ],
					"text" : "scale 0 1 -1 1"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-42",
					"maxclass" : "newobj",
					"numinlets" : 2,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 288.596488475799561, 80.409999999999997, 119.0, 22.0 ],
					"text" : "lookup fricativeNoise"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-41",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 288.596488475799561, 25.438596248626709, 65.0, 22.0 ],
					"text" : "phasor 0.5"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-40",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 434.0, 80.409999999999997, 114.0, 22.0 ],
					"text" : "buffer fricativeNoise"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-39",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 647.368414878845215, 14.0, 28.0, 22.0 ],
					"text" : "in 2"
				}

			}
, 			{
				"box" : 				{
					"code" : "moveTowards(current, target, amountUp, amountDown) {\r\n    if (current < target) {\r\n\t\treturn min(current + amountUp, target);\r\n\t}\r\n    else {\r\n\t\treturn max(current-amountDown, target);\r\n\t}\r\n}\r\n\r\nParam n(44, min=30, max=44);\r\n\r\nParam movementSpeed(15, min=0);\r\n\r\nHistory velumTarget(0.01);\r\n\r\nParam tongueIndex(12.9);\r\nParam tongueDiameter(2.43, min=2.05, max=3.5);\r\nParam constrictionIndex(0, min=0, max=44);\r\nParam constrictionDiameter(0);\r\n\r\nBuffer targetDiameter;\r\nBuffer noseDiameter;\r\nBuffer diameter;\r\n\r\nData tonguePosition(2); //tongue [index, diameter]\r\nData constriction(2); //constriction (held mouse) [index, diameter]\r\nData restDiameter(44);\r\n\r\nData R(44);\r\nData L(44);\r\nData A(44);\r\nData reflection(45);\r\nData newReflection(45);\r\nData junctionOutputR(45);\r\nData junctionOutputL(45);\r\n\r\nData noseL(28);\r\nData noseR(28);\r\nData noseA(28);\r\nData noseReflection(29);\r\nData noseJunctionOutputL(29);\r\nData noseJunctionOutputR(29);\r\n\r\nData reflectionLRN(3);\r\nData newReflectionLRN(3);\r\n\r\nData transients(44);\r\n\r\nHistory oldN(0);\r\nHistory sampCount(0);\r\nHistory lastObstruction(-1);\r\n\r\nblockLength = 32;\r\n\r\nglottalOutput = in1;\r\nturbulenceNoise = in2;\r\nnoiseModulator = in3;\r\n\r\nbladeStart = floor(10 * n/44);\r\nlipStart = floor(39 * n/44);\r\ntipStart = floor(32 * n/44);\r\nnoseLength = floor(28 * n/44);\r\nnoseStart = n - noseLength + 1; \r\n\r\n//init() (only when N changes)\r\nif (oldN != n) {\r\n\tfor (i = 0; i < n; i += 1) {\r\n    \td = 0;\r\n    \tif (i < 7 * n / 44-0.5) {\r\n\t\t\td = 0.6;\r\n\t\t}\r\n    \telse if (i < 12 * n / 44) {\r\n\t\t\td = 1.1;\r\n\t\t}\r\n    \telse {\r\n\t\t\td = 1.5;\r\n\t\t}\r\n\r\n\t\t//diameter.poke(d, i); //do this??\r\n\t\ttargetDiameter.poke(d, i);\r\n\t\trestDiameter.poke(d, i);\r\n\t\t\r\n\t\t/*\r\n\t\tR.poke(0, i);\r\n\t\tL.poke(0, i);\r\n\t\tA.poke(0, i);\r\n\t\tjunctionOutputR.poke(0, i);\r\n\t\tjunctionOutputL.poke(0, i);\r\n\t\treflection.poke(0, i);\r\n\t\tnewReflection.poke(0, i);\r\n\t\t*/\r\n\t}\r\n\r\n\tfor (i = 0; i < noseLength; i += 1) {\r\n    \tdia = 0;\r\n    \td = 2 * (i / noseLength);\r\n    \tif (d < 1) {\r\n\t\t\tdia = 0.4 + 1.6 * d;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdia = 0.5 + 1.5 * (2 - d);\r\n\t\t}\r\n    \tdia = min(dia, 1.9);\r\n    \tnoseDiameter.poke(dia, i);\r\n\r\n\t\t/*\r\n\t\tnoseL.poke(0, i);\r\n\t\tnoseR.poke(0, i);\r\n\t\tnoseA.poke(0, i);\r\n\t\tnoseJunctionOutputL.poke(0, i);\r\n\t\tnoseJunctionOutputR.poke(0, i);\r\n\t\tnoseReflection.poke(0, i);\r\n\t\t*/\r\n\t}   \r\n\t\r\n\t//for (i = 0; i < 3; i+= 1) {\r\n\t\t//newReflectionLRN.poke(0, i);\r\n\t//}\r\n\r\n\t//calculateReflections\r\n\t\r\n\tfor (i = 0; i < n; i += 1) {\r\n\t\tA.poke(diameter.peek(i) * diameter.peek(i), i);\r\n\t}\r\n\t\r\n\tfor (i = 1; i < n; i += 1)\r\n    {\r\n        //this.reflection[i] = this.newReflection[i];\r\n\t\treflection.poke(newReflection.peek(i), i);\r\n\t\t\r\n        //if (this.A[i] == 0) this.newReflection[i] = 0.999; //to prevent some bad behaviour if 0\r\n        //else this.newReflection[i] = (this.A[i-1]-this.A[i]) / (this.A[i-1]+this.A[i]); \r\n\t\tif (A.peek(i) == 0) {\r\n\t\t\tnewReflection.poke(0.999, i);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnewReflection.poke(( A.peek(i-1) - A.peek(i) ) / ( A.peek(i-1) + A.peek(i) ), i);\r\n\t\t}\r\n    }\r\n\r\n\treflectionLRN.poke(newReflectionLRN.peek(0), 0);\r\n\treflectionLRN.poke(newReflectionLRN.peek(1), 1);\r\n\treflectionLRN.poke(newReflectionLRN.peek(2), 2);\r\n\t\r\n\t//var sum = this.A[this.noseStart]+this.A[this.noseStart+1]+this.noseA[0];\t\r\n\tsum = A.peek(noseStart) + A.peek(noseStart + 1) + noseA.peek(0);\r\n\t\r\n\t\r\n    //this.newReflectionLeft = (2*this.A[this.noseStart]-sum)/sum;\r\n\tnewReflectionLRN.poke((2 * A.peek(noseStart) - sum) / sum, 0);\r\n\r\n    //this.newReflectionRight = (2*this.A[this.noseStart+1]-sum)/sum;   \r\n\tnewReflectionLRN.poke((2 * A.peek(noseStart + 1) - sum) / sum, 1);\r\n\r\n    //this.newReflectionNose = (2*this.noseA[0]-sum)/sum;    \r\n\tnewReflectionLRN.poke((2 * noseA.peek(0) - sum) / sum, 2);\r\n\t\r\n\t//calculateNoseReflections\r\n\t\r\n\tfor (i = 0; i < noseLength; i += 1) {\r\n\t\t// this.noseA[i] = this.noseDiameter[i]*this.noseDiameter[i]; \r\n\t\tnoseA.poke(noseDiameter.peek(i) * noseDiameter.peek(i), i);\r\n\t}\r\n\tfor (i = 1; i < noseLength; i += 1) {\r\n\t\t//this.noseReflection[i] = (this.noseA[i-1]-this.noseA[i]) / (this.noseA[i-1]+this.noseA[i]); \r\n\t\tnoseReflection.poke(( noseA.peek(i-1) - noseA.peek(i) ) / ( noseA.peek(i-1) + noseA.peek(i) ), i);\r\n\t}\r\n\t\r\n\tnoseDiameter.poke(velumTarget, 0);\t\r\n\t\r\n}\r\n\r\n//runStep (happens twice, once with lambda 0 and once with lambda 0.5)\r\n//\tthis is because blockLength is effectively 1\r\n\r\nvocalOutput = 0;\r\n\r\nfor (lambda = 0; lambda <= 0.5; lambda += 0.5) {\r\n\t\r\n\t//processTransients()\r\n\t//transients buffer sample indexes are tract diameter indexes\r\n\t//sample values are remaining time (if any) of transient at that index\r\n\t//(current time alive = lifetime - sample value)\r\n\t\r\n\tfor (i = 0; i < n; i+= 1) {\r\n\t\tval = transients.peek(i);\r\n\t\tif (transients.peek(i) > 0) {\r\n\t\t\tamplitude = 0.3 * pow(2, -200 * (0.2 - val));\r\n\t\t\tR.poke(R.peek(i) + amplitude/2, i);\r\n\t\t\tL.poke(L.peek(i) + amplitude/2, i);\r\n\t\t\ttransients.poke(transients.peek(i) - 1.0/(samplerate*2), i);\r\n\t\t}\r\n\t}\r\n\t\r\n\t//addTurbulenceNoise replacement\r\n\t//since there's no UI, get index/diameter of constriction using\r\n\t//locations/heights of \"valleys\" in diameter values\r\n\tfor (i = 1; i < (n - 1); i+= 1) {\r\n\t\td = diameter.peek(i);\r\n\t\tif (d < diameter.peek(i-1) && d < diameter.peek(i+1) && d > 0 &&\r\n\t\t\trestDiameter.peek(i) != targetDiameter.peek(i)) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\td += 0.3; //offset diameter a bit to get \"touch\" diameter\r\n\t\t\t\r\n\t\t\t//\"addTurbulenceNoiseAtIndex()\"\r\n\t\t\t//index = i; diameter = d, intensity = 1 (reevaluate?)\r\n\t\t\t//1119\r\n\t\t\tnoise = 0.66 * turbulenceNoise * noiseModulator;\r\n\t\t\t\r\n\t\t\tthinness0 = clamp(8 * (0.7 - d), 0, 1);\r\n\t\t\topenness = clamp(30 * (d - 0.3), 0, 1);\r\n\t\t\tnoise0 = noise * thinness0 * openness;\r\n\t\t\t//no noise1 because delta is always 0\r\n\t\t\t\r\n\t\t\tR.poke(R.peek(i+1) + noise0/2, i+1);\r\n\t\t\tL.poke(L.peek(i+1) + noise0/2, i+1);\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\t\r\n\t//1000 this.junctionOutputR[0] = this.L[0] * this.glottalReflection + glottalOutput;\r\n\tjunctionOutputR.poke(L.peek(0) * 0.75 + glottalOutput, 0);\r\n\r\n\t//1001 this.junctionOutputL[this.n] = this.R[this.n-1] * this.lipReflection; \r\n\tjunctionOutputL.poke(R.peek(n-1) * -0.85, n);\r\n\r\n\tfor (i = 1; i < n; i += 1) { //1003\r\n\t\r\n\t\t//1005 var r = this.reflection[i] * (1-lambda) + this.newReflection[i]*lambda;\r\n\t\tr = reflection.peek(i) * (1-lambda) + newReflection.peek(i) * lambda;\r\n\t\r\n\t\t//1006 var w = r * (this.R[i-1] + this.L[i]);\r\n\t\tw = r * (R.peek(i-1) + L.peek(i));\r\n\t\r\n\t\t//1007 this.junctionOutputR[i] = this.R[i-1] - w;\r\n\t\tjunctionOutputR.poke(R.peek(i-1) - w, i);\r\n\t\r\n\t\t//1008 this.junctionOutputL[i] = this.L[i] + w;\r\n\t\tjunctionOutputL.poke(L.peek(i) + w, i);\r\n\t}\r\n\r\n\ti = noseStart;\r\n\r\n\t//1013 var r = this.newReflectionLeft * (1-lambda) + this.reflectionLeft*lambda;\r\n\tr = newReflectionLRN.peek(0) * (1-lambda) + reflectionLRN.peek(0) * lambda;\r\n\r\n\t//1014 this.junctionOutputL[i] = r*this.R[i-1]+(1+r)*(this.noseL[0]+this.L[i]);\r\n\tjunctionOutputL.poke(r * R.peek(i-1) + (1+r) * (noseL.peek(0) + L.peek(i)), i);\r\n\r\n\t//1015 r = this.newReflectionRight * (1-lambda) + this.reflectionRight*lambda;\r\n\tr = newReflectionLRN.peek(1) * (1-lambda) + reflectionLRN.peek(1) * lambda;\r\n\r\n\t//1016 this.junctionOutputR[i] = r*this.L[i]+(1+r)*(this.R[i-1]+this.noseL[0]);     \r\n\tjunctionOutputR.poke(r * L.peek(i) + (1+r) * (R.peek(i-1) + noseL.peek(0)), i);\r\n\r\n\t//1017 r = this.newReflectionNose * (1-lambda) + this.reflectionNose*lambda;\r\n\tr = newReflectionLRN.peek(2) * (1-lambda) + reflectionLRN.peek(2) * lambda;\r\n\r\n\t//1018 this.noseJunctionOutputR[0] = r*this.noseL[0]+(1+r)*(this.L[i]+this.R[i-1]);\r\n\tnoseJunctionOutputR.poke(r * noseL.peek(0) + (1+r) * (L.peek(i) + R.peek(i-1)), 0);\r\n\r\n\tfor (i = 0; i < n; i += 1) { //1019\r\n\t\r\n\t\t//1021 this.R[i] = this.junctionOutputR[i]*0.999;\r\n\t\tR.poke(junctionOutputR.peek(i) * 0.999, i);\r\n\t\r\n    \t//1022 this.L[i] = this.junctionOutputL[i+1]*0.999; \r\n\t\tL.poke(junctionOutputL.peek(i+1) * 0.999, i);\r\n\t}\r\n\t\r\n\tvocalOutput += R.peek(n - 1);\r\n\r\n\r\n\t//1039 this.noseJunctionOutputL[this.noseLength] = this.noseR[this.noseLength-1] * this.lipReflection; \r\n\tnoseJunctionOutputL.poke(noseR.peek(noseLength - 1) * -0.85, noseLength);\r\n\r\n\tfor (i = 1; i < noseLength; i += 1) {\r\n\t\t//1043 var w = this.noseReflection[i] * (this.noseR[i-1] + this.noseL[i]);\r\n\t\tw = noseReflection.peek(i) * (noseR.peek(i-1) + noseL.peek(i));\r\n\t\r\n\t\t//1044 this.noseJunctionOutputR[i] = this.noseR[i-1] - w;\r\n\t\tnoseJunctionOutputR.poke(noseR.peek(i-1) - w, i);\r\n\t\r\n\t\t//1045 this.noseJunctionOutputL[i] = this.noseL[i] + w;\r\n\t\tnoseJunctionOutputL.poke(noseL.peek(i) + w, i);\r\n\t}\r\n\r\n\tfor (i = 0; i < noseLength; i += 1) {\r\n\t\r\n\t\t//1050 this.noseR[i] = this.noseJunctionOutputR[i] * this.fade; \r\n\t\tnoseR.poke(noseJunctionOutputR.peek(i), i);\r\n\t\r\n\t\t//1051 this.noseL[i] = this.noseJunctionOutputL[i+1] * this.fade;   \r\n\t\tnoseL.poke(noseJunctionOutputL.peek(i+1), i);\t\r\n\t}\r\n\r\n\tvocalOutput += noseR.peek(noseLength-1);\r\n\t\t\r\n}\r\n\r\n//finishBlock\r\n\r\nif (sampCount % blockLength == 0) {\r\n\t\r\n\t//reshapeTract\r\n\t\r\n\t//var amount = blockLength/AudioSystem.get(\"sampleRate\") * tractParams.get(\"movementSpeed\");\r\n\tamount = blockLength / samplerate * movementSpeed;\r\n\tnewLastObstruction = -1;\r\n\t\r\n\tfor (i = 0; i < n; i += 1) {\r\n\t\td = diameter.peek(i);\r\n\t\ttd = targetDiameter.peek(i);\r\n\t\tif (d <= 0) {\r\n\t\t\tnewLastObstruction = i;\r\n\t\t}\r\n\t\tslowReturn = 0;\r\n\t\tif (i < noseStart) {\r\n\t\t\tslowReturn = 0.6;\r\n\t\t}\r\n\t\telse if (i >= tipStart) {\r\n\t\t\tslowReturn = 1.0; \r\n\t\t}\r\n\t\telse {\r\n\t\t\tslowReturn = 0.6 + 0.4*(i-noseStart) / (tipStart-noseStart);\r\n\t\t}\r\n\t\t\r\n\t\tnewVal = moveTowards(d, td, slowReturn*amount, 2*amount);\t\t\r\n\t\tdiameter.poke(newVal, i);\r\n\t}\r\n\t\r\n\tif (lastObstruction > -1 && newLastObstruction == -1 && noseA.peek(0) < 0.05) {\r\n\t\ttransients.poke(.2, lastObstruction);\r\n\t}\r\n\tlastObstruction = newLastObstruction;\r\n\t\t\r\n\tnoseDiameter.poke(moveTowards(noseDiameter.peek(0), velumTarget, \r\n        amount*0.25, amount*0.1), 0);\r\n\tnoseA.poke(pow(noseDiameter.peek(0), 2), 0); \r\n\t\r\n\t//calculatereflections\r\n\t\r\n\tfor (i = 0; i < n; i+= 1) {\r\n\t\tA.poke(diameter.peek(i) * diameter.peek(i), i);\r\n\t}\r\n\t\r\n\tfor (i = 1; i < n; i += 1)\r\n    {\r\n        //this.reflection[i] = this.newReflection[i];\r\n\t\treflection.poke(newReflection.peek(i), i);\r\n\t\t\r\n        //if (this.A[i] == 0) this.newReflection[i] = 0.999; //to prevent some bad behaviour if 0\r\n        //else this.newReflection[i] = (this.A[i-1]-this.A[i]) / (this.A[i-1]+this.A[i]); \r\n\t\tif (A.peek(i) == 0) {\r\n\t\t\tnewReflection.poke(0.999, i);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnewReflection.poke(( A.peek(i-1) - A.peek(i) ) / ( A.peek(i-1) + A.peek(i) ), i);\r\n\t\t}\r\n    }\r\n\r\n\treflectionLRN.poke(newReflectionLRN.peek(0), 0);\r\n\treflectionLRN.poke(newReflectionLRN.peek(1), 1);\r\n\treflectionLRN.poke(newReflectionLRN.peek(2), 2);\r\n\t\r\n\t//var sum = this.A[this.noseStart]+this.A[this.noseStart+1]+this.noseA[0];\t\r\n\tsum = A.peek(noseStart) + A.peek(noseStart + 1) + noseA.peek(0);\r\n\t\r\n    //this.newReflectionLeft = (2*this.A[this.noseStart]-sum)/sum;\r\n\tnewReflectionLRN.poke((2 * A.peek(noseStart) - sum) / sum, 0);\r\n\r\n    //this.newReflectionRight = (2*this.A[this.noseStart+1]-sum)/sum;   \r\n\tnewReflectionLRN.poke((2 * A.peek(noseStart + 1) - sum) / sum, 1);\r\n\r\n    //this.newReflectionNose = (2*this.noseA[0]-sum)/sum;    \r\n\tnewReflectionLRN.poke((2 * noseA.peek(0) - sum) / sum, 2);\r\n}\r\n\r\n//when tongue or constriction position change\r\nif (tongueIndex != tonguePosition.peek(0) || tongueDiameter != tonguePosition.peek(1) ||\r\n\tconstrictionIndex != constriction.peek(0) || constrictionDiameter != constriction.peek(1) ||\r\n\toldN != n) {\r\n\r\n\ttonguePosition.poke(tongueIndex, 0);\r\n\ttonguePosition.poke(tongueDiameter, 1);\r\n\tconstriction.poke(constrictionIndex, 0);\r\n\tconstriction.poke(constrictionDiameter, 1);\r\n\t\r\n\t//setRestDiameter\r\n\tfor (i = bladeStart; i < lipStart; i+= 1) { \r\n        t = 1.1 * PI*(tongueIndex - i)/(tipStart - bladeStart);\r\n        fixedTongueDiameter = 2+(tongueDiameter-2)/1.5;\r\n        curve = (1.5-fixedTongueDiameter+1.7)*cos(t);\r\n        if (i == bladeStart-2 || i == lipStart-1) {\r\n\t\t\tcurve *= 0.8;\r\n\t\t}\r\n        if (i == bladeStart || i == lipStart-2) {\r\n\t\t\tcurve *= 0.94;               \r\n\t\t}\r\n        restDiameter.poke(1.5 - curve, i);\r\n    }\r\n\tfor (i = 0; i < n; i+= 1) {\r\n\t\ttargetDiameter.poke(restDiameter.peek(i), i);\r\n\t}\r\n\t\r\n\tnoseOffset = 0.8;\r\n\t\r\n\tvelumTarget = 0.01;\r\n\t\r\n\tif (constrictionIndex > noseStart && constrictionDiameter < -noseOffset) {\r\n\t\tvelumTarget = 0.4;\r\n\t}\r\n\t\r\n\t\r\n\tif (constrictionDiameter >= -0.85-noseOffset) {\r\n\t\tdia = max(0, constrictionDiameter - 0.3);\r\n\t\tindex = constrictionIndex - 1;\r\n\r\n\r\n\t\twidth = 0;\r\n    \tif (index < 25) {\r\n\t\t\twidth = 10;\r\n\t\t}\r\n    \telse if (index >= tipStart) {\r\n\t\t\twidth = 5;\r\n\t\t}\r\n    \telse {\r\n\t\t\twidth = 10 - 5*(index-25) / (tipStart-25);\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tif (index >= 2 && index < n && dia < 3) {\r\n\t\t\tintIndex = round(index);\r\n\t\t\t\r\n\t\t\tfor (i = -ceil(width) - 1; i < width + 1; i+= 1) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\tif (!(intIndex+i < 0 || intIndex+i >= n)) {\r\n\r\n\t\t\t\t\trelpos = (intIndex+i) - index;\r\n\t\t\t\t\trelpos = abs(relpos) - 0.5;\r\n\t\t\t\t\tshrink = 0;\r\n            \t\tif (relpos <= 0) {\r\n\t\t\t\t\t\tshrink = 0;\r\n\t\t\t\t\t}\r\n            \t\telse if (relpos > width) {\r\n\t\t\t\t\t\tshrink = 1;\r\n\t\t\t\t\t}\r\n            \t\telse {\r\n\t\t\t\t\t\tshrink = 0.5*(1 - cos(PI * relpos / width));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (dia < targetDiameter.peek(intIndex + i)) {\r\n\t\t\t\t\t\ttargetDiameter.poke(dia + (targetDiameter.peek(intIndex+i) - dia) * shrink, intIndex+i);\r\n\t\t\t\t\t}\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\noldN = n;\r\n\r\nsampCount = sampCount + 1;\r\n\r\nout1 = vocalOutput / 8;\r\n",
					"fontface" : 0,
					"fontname" : "<Monospaced>",
					"fontsize" : 12.0,
					"id" : "obj-9",
					"maxclass" : "codebox",
					"numinlets" : 3,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 30.927836894989014, 112.371140718460083, 688.659834861755371, 274.226820468902588 ]
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-1",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 50.0, 14.0, 28.0, 22.0 ],
					"text" : "in 1"
				}

			}
 ],
		"lines" : [ 			{
				"patchline" : 				{
					"destination" : [ "obj-9", 0 ],
					"source" : [ "obj-1", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-9", 2 ],
					"source" : [ "obj-39", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-43", 0 ],
					"source" : [ "obj-41", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-9", 1 ],
					"source" : [ "obj-42", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-42", 0 ],
					"source" : [ "obj-43", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-44", 0 ],
					"source" : [ "obj-9", 0 ]
				}

			}
 ]
	}

}
